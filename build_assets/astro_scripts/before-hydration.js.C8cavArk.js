import{s as d,R as m,Q as v}from"../lit-html.CzCPjovT.js";/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */let f=null;const A={boundAttributeSuffix:d.M,marker:d.P,markerMatch:d.A,HTML_RESULT:d.C,getTemplateHtml:d.L,overrideDirectiveResolve:(t,r)=>class extends t{_$AS(o,a){return r(this,a)}},patchDirectiveResolve:(t,r)=>{if(t.prototype._$AS!==r){f??=t.prototype._$AS.name;for(let o=t.prototype;o!==Object.prototype;o=Object.getPrototypeOf(o))if(o.hasOwnProperty(f))return void(o[f]=r);throw Error("Internal error: It is possible that both dev mode and production mode Lit was mixed together during SSR. Please comment on the issue: https://github.com/lit/lit/issues/4527")}},setDirectiveClass(t,r){t._$litDirective$=r},getAttributePartCommittedValue:(t,r,o)=>{let a=m;return t.j=n=>a=n,t._$AI(r,t,o),a},connectedDisconnectable:t=>({...t,_$AU:!0}),resolveDirective:d.V,AttributePart:d.H,PropertyPart:d.B,BooleanAttributePart:d.N,EventPart:d.U,ElementPart:d.F,TemplateInstance:d.R,isIterable:d.D,ChildPart:d.I};/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const p={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6};/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const E=t=>t===null||typeof t!="object"&&typeof t!="function",g=(t,r)=>t?._$litType$!==void 0,P=t=>t?._$litType$?.h!=null,w=t=>t.strings===void 0;/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{TemplateInstance:T,isIterable:$,resolveDirective:y,ChildPart:h,ElementPart:_}=A,I=(t,r,o={})=>{if(r._$litPart$!==void 0)throw Error("container already contains a live render");let a,n,i;const e=[],c=document.createTreeWalker(r,NodeFilter.SHOW_COMMENT);let l;for(;(l=c.nextNode())!==null;){const s=l.data;if(s.startsWith("lit-part")){if(e.length===0&&a!==void 0)throw Error(`There must be only one root part per container. Found a part marker (${l}) when we already have a root part marker (${n})`);i=x(t,l,e,o),a===void 0&&(a=i),n??=l}else if(s.startsWith("lit-node"))O(l,e,o);else if(s.startsWith("/lit-part")){if(e.length===1&&i!==a)throw Error("internal error");i=R(l,i,e)}}if(a===void 0){const s=r instanceof ShadowRoot?"{container.host.localName}'s shadow root":r instanceof DocumentFragment?"DocumentFragment":r.localName;console.error(`There should be exactly one root part in a render container, but we didn't find any in ${s}.`)}r._$litPart$=a},x=(t,r,o,a)=>{let n,i;if(o.length===0)i=new h(r,null,void 0,a),n=t;else{const e=o[o.length-1];if(e.type==="template-instance")i=new h(r,null,e.instance,a),e.instance._$AV.push(i),n=e.result.values[e.instancePartIndex++],e.templatePartIndex++;else if(e.type==="iterable"){i=new h(r,null,e.part,a);const c=e.iterator.next();if(c.done)throw n=void 0,e.done=!0,Error("Unhandled shorter than expected iterable");n=c.value,e.part._$AH.push(i)}else i=new h(r,null,e.part,a)}if(n=y(i,n),n===m)o.push({part:i,type:"leaf"});else if(E(n))o.push({part:i,type:"leaf"}),i._$AH=n;else if(g(n)){if(P(n))throw Error("compiled templates are not supported");const e="lit-part "+C(n);if(r.data!==e)throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const c=h.prototype._$AC(n),l=new T(c,i);o.push({type:"template-instance",instance:l,part:i,templatePartIndex:0,instancePartIndex:0,result:n}),i._$AH=l}}else $(n)?(o.push({part:i,type:"iterable",value:n,iterator:n[Symbol.iterator](),done:!1}),i._$AH=[]):(o.push({part:i,type:"leaf"}),i._$AH=n??"");return i},R=(t,r,o)=>{if(r===void 0)throw Error("unbalanced part marker");r._$AB=t;const a=o.pop();if(a.type==="iterable"&&!a.iterator.next().done)throw Error("unexpected longer than expected iterable");if(o.length>0)return o[o.length-1].part},O=(t,r,o)=>{const a=/lit-node (\d+)/.exec(t.data),n=parseInt(a[1]),i=t.nextElementSibling;if(i===null)throw Error("could not find node for attribute parts");i.removeAttribute("defer-hydration");const e=r[r.length-1];if(e.type!=="template-instance")throw Error("Hydration value mismatch: Primitive found where TemplateResult expected. This usually occurs due to conditional rendering that resulted in a different value or template being rendered between the server and client.");{const c=e.instance;for(;;){const l=c._$AD.parts[e.templatePartIndex];if(l===void 0||l.type!==p.ATTRIBUTE&&l.type!==p.ELEMENT||l.index!==n)break;if(l.type===p.ATTRIBUTE){const s=new l.ctor(i,l.name,l.strings,e.instance,o),u=w(s)?e.result.values[e.instancePartIndex]:e.result.values,b=!(s.type===p.EVENT||s.type===p.PROPERTY);s._$AI(u,s,e.instancePartIndex,b),e.instancePartIndex+=l.strings.length-1,c._$AV.push(s)}else{const s=new _(i,e.instance,o);y(s,e.result.values[e.instancePartIndex++]),c._$AV.push(s)}e.templatePartIndex++}}},C=t=>{const r=new Uint32Array(2).fill(5381);for(const a of t.strings)for(let n=0;n<a.length;n++)r[n%2]=33*r[n%2]^a.charCodeAt(n);const o=String.fromCharCode(...new Uint8Array(r.buffer));return btoa(o)};globalThis.litElementHydrateSupport=({LitElement:t})=>{const r=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t),"observedAttributes").get;Object.defineProperty(t,"observedAttributes",{get(){return[...r.call(this),"defer-hydration"]}});const o=t.prototype.attributeChangedCallback;t.prototype.attributeChangedCallback=function(e,c,l){e==="defer-hydration"&&l===null&&a.call(this),o.call(this,e,c,l)};const a=t.prototype.connectedCallback;t.prototype.connectedCallback=function(){this.hasAttribute("defer-hydration")||a.call(this)};const n=t.prototype.createRenderRoot;t.prototype.createRenderRoot=function(){return this.shadowRoot?(this._$AG=!0,this.shadowRoot):n.call(this)};const i=Object.getPrototypeOf(t.prototype).update;t.prototype.update=function(e){const c=this.render();if(i.call(this,e),this._$AG){this._$AG=!1;for(let l=0;l<this.attributes.length;l++){const s=this.attributes[l];if(s.name.startsWith("hydrate-internals-")){const u=s.name.slice(18);this.removeAttribute(u),this.removeAttribute(s.name)}}I(c,this.renderRoot,this.renderOptions)}else v(c,this.renderRoot,this.renderOptions)}};
